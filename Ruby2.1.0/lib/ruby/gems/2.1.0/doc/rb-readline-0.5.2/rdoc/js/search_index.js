var search_data = {"index":{"searchIndex":["fixnum","rbreadline","win32api","readline","filename_completion_proc","fcomp","history","history","username_completion_proc","ucomp","<<()","<<()","call()","[]()","[]()","[]=()","[]=()","__rl_fix_point()","_extract_last_quote()","_rl_abort_internal()","_rl_adjust_point()","_rl_any_typein()","_rl_arg_dispatch()","_rl_arg_getchar()","_rl_arg_init()","_rl_arg_overflow()","_rl_backspace()","_rl_bind_tty_special_chars()","_rl_char_search()","_rl_char_search_internal()","_rl_char_value()","_rl_clean_up_for_exit()","_rl_clear_screen()","_rl_clear_to_eol()","_rl_col_width()","_rl_compare_chars()","_rl_control_keypad()","_rl_copy_to_kill_ring()","_rl_current_display_line()","_rl_dispatch()","_rl_dispatch_subseq()","_rl_enable_meta_key()","_rl_erase_at_end_of_line()","_rl_erase_entire_line()","_rl_find_completion_word()","_rl_find_next_mbchar()","_rl_find_prev_mbchar()","_rl_fix_point()","_rl_get_char_len()","_rl_get_screen_size()","_rl_history_set_point()","_rl_init_eightbit()","_rl_init_line_state()","_rl_init_terminal_io()","_rl_input_available()","_rl_insert_char()","_rl_insert_next()","_rl_insert_typein()","_rl_internal_char_cleanup()","_rl_internal_pager()","_rl_is_mbchar_matched()","_rl_isearch_cleanup()","_rl_isearch_dispatch()","_rl_isearch_fini()","_rl_isearch_init()","_rl_make_prompt_for_search()","_rl_move_cursor_relative()","_rl_move_vert()","_rl_nsearch_abort()","_rl_nsearch_cleanup()","_rl_nsearch_dispatch()","_rl_nsearch_dosearch()","_rl_nsearch_init()","_rl_output_some_chars()","_rl_overwrite_char()","_rl_overwrite_rubout()","_rl_read_init_file()","_rl_read_mbchar()","_rl_read_mbstring()","_rl_redisplay_after_sigwinch()","_rl_replace_text()","_rl_reset_argument()","_rl_rubout_char()","_rl_scxt_alloc()","_rl_search_getchar()","_rl_set_insert_mode()","_rl_set_mark_at_pos()","_rl_start_using_history()","_rl_strip_prompt()","_rl_subseq_getchar()","_rl_to_lower()","_rl_unget_char()","_rl_update_final()","_rl_vi_done_inserting()","_rl_vi_initialize_line()","_rl_vi_reset_last()","_rl_vi_save_insert()","_rl_vi_textmod_command()","_rl_walphabetic()","add_history()","alloc_history_entry()","alloc_undo_entry()","append_to_match()","basic_quote_characters()","basic_quote_characters=()","basic_word_break_characters()","basic_word_break_characters=()","bind_arrow_keys()","bind_arrow_keys_internal()","bind_termcap_arrow_keys()","block_sigint()","call()","call()","call()","call()","call()","clear_history()","completer_quote_characters()","completer_quote_characters=()","completer_word_break_characters()","completer_word_break_characters=()","completion_append_character()","completion_append_character=()","completion_case_fold()","completion_case_fold=()","completion_proc()","completion_proc=()","compute_lcd_of_matches()","cr()","cr_faster()","ctrl_char()","current_history()","delete_at()","delete_at()","delete_chars()","display_matches()","each()","each()","emacs_editing_mode()","empty?()","empty?()","endsrch_char()","expand_prompt()","filename_quote_characters()","filename_quote_characters=()","fnprint()","fnwidth()","gen_completion_matches()","get_term_capabilities()","get_y_or_n()","handle_parser_directive()","hist_inittime()","history_arg_extract()","history_get()","history_is_stifled()","history_list()","history_search_pos()","history_search_prefix()","history_set_pos()","ibuffer_space()","init_line_structures()","input=()","insert_all_matches()","insert_match()","insert_some_chars()","inv_line()","inv_llen()","isascii()","isprint()","length()","length()","line_buffer()","m_offset()","make_history_line_current()","make_quoted_replacement()","meta_char()","new()","next_history()","no_terminal?()","noninc_dosearch()","noninc_search()","noninc_search_from_pos()","ord()","output=()","parser_else()","parser_endif()","parser_if()","parser_include()","path_isdir()","point()","pop()","pop()","postprocess_matches()","prepare_terminal_settings()","previous_history()","print_filename()","printable_part()","prompt_ending_index()","push()","push()","rb_remove_history()","rb_remove_history()","readline()","readline()","readline()","readline_attempted_completion_function()","readline_default_bindings()","readline_initialize_everything()","readline_internal()","readline_internal_charloop()","readline_internal_setup()","readline_internal_teardown()","redraw_prompt()","release_sigint()","remove_duplicate_matches()","remove_history()","replace_history_data()","replace_history_entry()","retry_if_interrupted()","rl_abort()","rl_add_undo()","rl_alphabetic()","rl_arrow_keys()","rl_backward()","rl_backward_byte()","rl_backward_char()","rl_backward_char_search()","rl_backward_kill_line()","rl_backward_kill_word()","rl_backward_word()","rl_beg_of_line()","rl_begin_undo_group()","rl_beginning_of_history()","rl_bind_key()","rl_bind_keyseq_if_unbound()","rl_bind_keyseq_if_unbound_in_map()","rl_bind_keyseq_in_map()","rl_capitalize_word()","rl_change_case()","rl_char_search()","rl_character_len()","rl_cleanup_after_signal()","rl_clear_message()","rl_clear_pending_input()","rl_clear_screen()","rl_clear_signals()","rl_complete()","rl_complete_internal()","rl_completion_matches()","rl_copy_text()","rl_crlf()","rl_delete()","rl_delete_horizontal_space()","rl_delete_or_show_completions()","rl_delete_text()","rl_deprep_terminal()","rl_digit_argument()","rl_digit_loop()","rl_ding()","rl_display_match_list()","rl_display_search()","rl_do_lowercase_version()","rl_do_undo()","rl_downcase_word()","rl_emacs_editing_mode()","rl_end_of_history()","rl_end_of_line()","rl_end_undo_group()","rl_exchange_point_and_mark()","rl_execute_next()","rl_expand_prompt()","rl_extend_line_buffer()","rl_filename_completion_function()","rl_forced_update_display()","rl_forward()","rl_forward_byte()","rl_forward_char()","rl_forward_search_history()","rl_forward_word()","rl_free_undo_list()","rl_function_of_keyseq()","rl_gather_tyi()","rl_generic_bind()","rl_get_char()","rl_get_keymap_name_from_edit_mode()","rl_get_next_history()","rl_get_previous_history()","rl_getc()","rl_initialize()","rl_insert()","rl_insert_comment()","rl_insert_completions()","rl_insert_text()","rl_isstate()","rl_kill_full_line()","rl_kill_line()","rl_kill_text()","rl_kill_word()","rl_line_buffer()","rl_maybe_replace_line()","rl_maybe_save_line()","rl_maybe_unsave_line()","rl_message()","rl_modifying()","rl_named_function()","rl_newline()","rl_noninc_forward_search()","rl_noninc_reverse_search()","rl_on_new_line()","rl_on_new_line_with_prompt()","rl_overwrite_mode()","rl_parse_and_bind()","rl_possible_completions()","rl_prep_terminal()","rl_quoted_insert()","rl_re_read_init_file()","rl_read_init_file()","rl_read_key()","rl_redisplay()","rl_refresh_line()","rl_replace_from_history()","rl_replace_line()","rl_reset_line_state()","rl_resize_terminal()","rl_restart_output()","rl_restore_prompt()","rl_reverse_search_history()","rl_revert_line()","rl_rubout()","rl_rubout_or_delete()","rl_save_prompt()","rl_search_history()","rl_set_keymap_from_edit_mode()","rl_set_mark()","rl_set_prompt()","rl_set_signals()","rl_setstate()","rl_sigwinch_handler()","rl_stuff_char()","rl_tab_insert()","rl_tilde_expand()","rl_transpose_chars()","rl_transpose_words()","rl_tty_set_default_bindings()","rl_tty_unset_default_bindings()","rl_undo_command()","rl_unix_filename_rubout()","rl_unix_line_discard()","rl_unix_word_rubout()","rl_unsetstate()","rl_upcase_word()","rl_username_completion_function()","rl_variable_bind()","rl_vi_check()","rl_vi_editing_mode()","rl_vi_insertion_mode()","rl_yank()","rl_yank_last_arg()","rl_yank_nth_arg()","rl_yank_nth_arg_internal()","rl_yank_pop()","save_tty_chars()","set_completion_defaults()","sh_set_lines_and_columns()","shift()","shift()","size()","size()","space_to_eol()","stat_char()","stifle_history()","tgetflag()","to_s()","to_s()","trans()","unstifle_history()","update_line()","using_history()","vi_editing_mode()","vis_chars()","vis_line()","vis_llen()","vis_pos()","w_offset()","where_history()","whitespace()","changes","license","readme"],"longSearchIndex":["fixnum","rbreadline","rbreadline::win32api","readline","readline::filename_completion_proc","readline::fcomp","readline::history","readline::history","readline::username_completion_proc","readline::ucomp","readline::history::<<()","readline::history::<<()","rbreadline::win32api#call()","readline::history::[]()","readline::history::[]()","readline::history::[]=()","readline::history::[]=()","rbreadline#__rl_fix_point()","rbreadline#_extract_last_quote()","rbreadline#_rl_abort_internal()","rbreadline#_rl_adjust_point()","rbreadline#_rl_any_typein()","rbreadline#_rl_arg_dispatch()","rbreadline#_rl_arg_getchar()","rbreadline#_rl_arg_init()","rbreadline#_rl_arg_overflow()","rbreadline#_rl_backspace()","rbreadline#_rl_bind_tty_special_chars()","rbreadline#_rl_char_search()","rbreadline#_rl_char_search_internal()","rbreadline#_rl_char_value()","rbreadline#_rl_clean_up_for_exit()","rbreadline#_rl_clear_screen()","rbreadline#_rl_clear_to_eol()","rbreadline#_rl_col_width()","rbreadline#_rl_compare_chars()","rbreadline#_rl_control_keypad()","rbreadline#_rl_copy_to_kill_ring()","rbreadline#_rl_current_display_line()","rbreadline#_rl_dispatch()","rbreadline#_rl_dispatch_subseq()","rbreadline#_rl_enable_meta_key()","rbreadline#_rl_erase_at_end_of_line()","rbreadline#_rl_erase_entire_line()","rbreadline#_rl_find_completion_word()","rbreadline#_rl_find_next_mbchar()","rbreadline#_rl_find_prev_mbchar()","rbreadline#_rl_fix_point()","rbreadline#_rl_get_char_len()","rbreadline#_rl_get_screen_size()","rbreadline#_rl_history_set_point()","rbreadline#_rl_init_eightbit()","rbreadline#_rl_init_line_state()","rbreadline#_rl_init_terminal_io()","rbreadline#_rl_input_available()","rbreadline#_rl_insert_char()","rbreadline#_rl_insert_next()","rbreadline#_rl_insert_typein()","rbreadline#_rl_internal_char_cleanup()","rbreadline#_rl_internal_pager()","rbreadline#_rl_is_mbchar_matched()","rbreadline#_rl_isearch_cleanup()","rbreadline#_rl_isearch_dispatch()","rbreadline#_rl_isearch_fini()","rbreadline#_rl_isearch_init()","rbreadline#_rl_make_prompt_for_search()","rbreadline#_rl_move_cursor_relative()","rbreadline#_rl_move_vert()","rbreadline#_rl_nsearch_abort()","rbreadline#_rl_nsearch_cleanup()","rbreadline#_rl_nsearch_dispatch()","rbreadline#_rl_nsearch_dosearch()","rbreadline#_rl_nsearch_init()","rbreadline#_rl_output_some_chars()","rbreadline#_rl_overwrite_char()","rbreadline#_rl_overwrite_rubout()","rbreadline#_rl_read_init_file()","rbreadline#_rl_read_mbchar()","rbreadline#_rl_read_mbstring()","rbreadline#_rl_redisplay_after_sigwinch()","rbreadline#_rl_replace_text()","rbreadline#_rl_reset_argument()","rbreadline#_rl_rubout_char()","rbreadline#_rl_scxt_alloc()","rbreadline#_rl_search_getchar()","rbreadline#_rl_set_insert_mode()","rbreadline#_rl_set_mark_at_pos()","rbreadline#_rl_start_using_history()","rbreadline#_rl_strip_prompt()","rbreadline#_rl_subseq_getchar()","rbreadline#_rl_to_lower()","rbreadline#_rl_unget_char()","rbreadline#_rl_update_final()","rbreadline#_rl_vi_done_inserting()","rbreadline#_rl_vi_initialize_line()","rbreadline#_rl_vi_reset_last()","rbreadline#_rl_vi_save_insert()","rbreadline#_rl_vi_textmod_command()","rbreadline#_rl_walphabetic()","rbreadline#add_history()","rbreadline#alloc_history_entry()","rbreadline#alloc_undo_entry()","rbreadline#append_to_match()","readline::basic_quote_characters()","readline::basic_quote_characters=()","readline::basic_word_break_characters()","readline::basic_word_break_characters=()","rbreadline#bind_arrow_keys()","rbreadline#bind_arrow_keys_internal()","rbreadline#bind_termcap_arrow_keys()","rbreadline#block_sigint()","rbreadline::win32api#call()","readline::fcomp::call()","readline::fcomp::call()","readline::ucomp::call()","readline::ucomp::call()","rbreadline#clear_history()","readline::completer_quote_characters()","readline::completer_quote_characters=()","readline::completer_word_break_characters()","readline::completer_word_break_characters=()","readline::completion_append_character()","readline::completion_append_character=()","readline::completion_case_fold()","readline::completion_case_fold=()","readline::completion_proc()","readline::completion_proc=()","rbreadline#compute_lcd_of_matches()","rbreadline#cr()","rbreadline#cr_faster()","rbreadline#ctrl_char()","rbreadline#current_history()","readline::history::delete_at()","readline::history::delete_at()","rbreadline#delete_chars()","rbreadline#display_matches()","readline::history::each()","readline::history::each()","readline::emacs_editing_mode()","readline::history::empty?()","readline::history::empty?()","rbreadline#endsrch_char()","rbreadline#expand_prompt()","readline::filename_quote_characters()","readline::filename_quote_characters=()","rbreadline#fnprint()","rbreadline#fnwidth()","rbreadline#gen_completion_matches()","rbreadline#get_term_capabilities()","rbreadline#get_y_or_n()","rbreadline#handle_parser_directive()","rbreadline#hist_inittime()","rbreadline#history_arg_extract()","rbreadline#history_get()","rbreadline#history_is_stifled()","rbreadline#history_list()","rbreadline#history_search_pos()","rbreadline#history_search_prefix()","rbreadline#history_set_pos()","rbreadline#ibuffer_space()","rbreadline#init_line_structures()","readline::input=()","rbreadline#insert_all_matches()","rbreadline#insert_match()","rbreadline#insert_some_chars()","rbreadline#inv_line()","rbreadline#inv_llen()","rbreadline#isascii()","rbreadline#isprint()","readline::history::length()","readline::history::length()","readline::line_buffer()","rbreadline#m_offset()","rbreadline#make_history_line_current()","rbreadline#make_quoted_replacement()","rbreadline#meta_char()","rbreadline::win32api::new()","rbreadline#next_history()","rbreadline#no_terminal?()","rbreadline#noninc_dosearch()","rbreadline#noninc_search()","rbreadline#noninc_search_from_pos()","fixnum#ord()","readline::output=()","rbreadline#parser_else()","rbreadline#parser_endif()","rbreadline#parser_if()","rbreadline#parser_include()","rbreadline#path_isdir()","readline::point()","readline::history::pop()","readline::history::pop()","rbreadline#postprocess_matches()","rbreadline#prepare_terminal_settings()","rbreadline#previous_history()","rbreadline#print_filename()","rbreadline#printable_part()","rbreadline#prompt_ending_index()","readline::history::push()","readline::history::push()","readline::history::rb_remove_history()","readline::history::rb_remove_history()","rbreadline#readline()","readline#readline()","readline::readline()","readline::readline_attempted_completion_function()","rbreadline#readline_default_bindings()","rbreadline#readline_initialize_everything()","rbreadline#readline_internal()","rbreadline#readline_internal_charloop()","rbreadline#readline_internal_setup()","rbreadline#readline_internal_teardown()","rbreadline#redraw_prompt()","rbreadline#release_sigint()","rbreadline#remove_duplicate_matches()","rbreadline#remove_history()","rbreadline#replace_history_data()","rbreadline#replace_history_entry()","rbreadline#retry_if_interrupted()","rbreadline#rl_abort()","rbreadline#rl_add_undo()","rbreadline#rl_alphabetic()","rbreadline#rl_arrow_keys()","rbreadline#rl_backward()","rbreadline#rl_backward_byte()","rbreadline#rl_backward_char()","rbreadline#rl_backward_char_search()","rbreadline#rl_backward_kill_line()","rbreadline#rl_backward_kill_word()","rbreadline#rl_backward_word()","rbreadline#rl_beg_of_line()","rbreadline#rl_begin_undo_group()","rbreadline#rl_beginning_of_history()","rbreadline#rl_bind_key()","rbreadline#rl_bind_keyseq_if_unbound()","rbreadline#rl_bind_keyseq_if_unbound_in_map()","rbreadline#rl_bind_keyseq_in_map()","rbreadline#rl_capitalize_word()","rbreadline#rl_change_case()","rbreadline#rl_char_search()","rbreadline#rl_character_len()","rbreadline#rl_cleanup_after_signal()","rbreadline#rl_clear_message()","rbreadline#rl_clear_pending_input()","rbreadline#rl_clear_screen()","rbreadline#rl_clear_signals()","rbreadline#rl_complete()","rbreadline#rl_complete_internal()","rbreadline#rl_completion_matches()","rbreadline#rl_copy_text()","rbreadline#rl_crlf()","rbreadline#rl_delete()","rbreadline#rl_delete_horizontal_space()","rbreadline#rl_delete_or_show_completions()","rbreadline#rl_delete_text()","rbreadline#rl_deprep_terminal()","rbreadline#rl_digit_argument()","rbreadline#rl_digit_loop()","rbreadline#rl_ding()","rbreadline#rl_display_match_list()","rbreadline#rl_display_search()","rbreadline#rl_do_lowercase_version()","rbreadline#rl_do_undo()","rbreadline#rl_downcase_word()","rbreadline#rl_emacs_editing_mode()","rbreadline#rl_end_of_history()","rbreadline#rl_end_of_line()","rbreadline#rl_end_undo_group()","rbreadline#rl_exchange_point_and_mark()","rbreadline#rl_execute_next()","rbreadline#rl_expand_prompt()","rbreadline#rl_extend_line_buffer()","rbreadline#rl_filename_completion_function()","rbreadline#rl_forced_update_display()","rbreadline#rl_forward()","rbreadline#rl_forward_byte()","rbreadline#rl_forward_char()","rbreadline#rl_forward_search_history()","rbreadline#rl_forward_word()","rbreadline#rl_free_undo_list()","rbreadline#rl_function_of_keyseq()","rbreadline#rl_gather_tyi()","rbreadline#rl_generic_bind()","rbreadline#rl_get_char()","rbreadline#rl_get_keymap_name_from_edit_mode()","rbreadline#rl_get_next_history()","rbreadline#rl_get_previous_history()","rbreadline#rl_getc()","rbreadline#rl_initialize()","rbreadline#rl_insert()","rbreadline#rl_insert_comment()","rbreadline#rl_insert_completions()","rbreadline#rl_insert_text()","rbreadline#rl_isstate()","rbreadline#rl_kill_full_line()","rbreadline#rl_kill_line()","rbreadline#rl_kill_text()","rbreadline#rl_kill_word()","rbreadline#rl_line_buffer()","rbreadline#rl_maybe_replace_line()","rbreadline#rl_maybe_save_line()","rbreadline#rl_maybe_unsave_line()","rbreadline#rl_message()","rbreadline#rl_modifying()","rbreadline#rl_named_function()","rbreadline#rl_newline()","rbreadline#rl_noninc_forward_search()","rbreadline#rl_noninc_reverse_search()","rbreadline#rl_on_new_line()","rbreadline#rl_on_new_line_with_prompt()","rbreadline#rl_overwrite_mode()","rbreadline#rl_parse_and_bind()","rbreadline#rl_possible_completions()","rbreadline#rl_prep_terminal()","rbreadline#rl_quoted_insert()","rbreadline#rl_re_read_init_file()","rbreadline#rl_read_init_file()","rbreadline#rl_read_key()","rbreadline#rl_redisplay()","rbreadline#rl_refresh_line()","rbreadline#rl_replace_from_history()","rbreadline#rl_replace_line()","rbreadline#rl_reset_line_state()","rbreadline#rl_resize_terminal()","rbreadline#rl_restart_output()","rbreadline#rl_restore_prompt()","rbreadline#rl_reverse_search_history()","rbreadline#rl_revert_line()","rbreadline#rl_rubout()","rbreadline#rl_rubout_or_delete()","rbreadline#rl_save_prompt()","rbreadline#rl_search_history()","rbreadline#rl_set_keymap_from_edit_mode()","rbreadline#rl_set_mark()","rbreadline#rl_set_prompt()","rbreadline#rl_set_signals()","rbreadline#rl_setstate()","rbreadline#rl_sigwinch_handler()","rbreadline#rl_stuff_char()","rbreadline#rl_tab_insert()","rbreadline#rl_tilde_expand()","rbreadline#rl_transpose_chars()","rbreadline#rl_transpose_words()","rbreadline#rl_tty_set_default_bindings()","rbreadline#rl_tty_unset_default_bindings()","rbreadline#rl_undo_command()","rbreadline#rl_unix_filename_rubout()","rbreadline#rl_unix_line_discard()","rbreadline#rl_unix_word_rubout()","rbreadline#rl_unsetstate()","rbreadline#rl_upcase_word()","rbreadline#rl_username_completion_function()","rbreadline#rl_variable_bind()","rbreadline#rl_vi_check()","rbreadline#rl_vi_editing_mode()","rbreadline#rl_vi_insertion_mode()","rbreadline#rl_yank()","rbreadline#rl_yank_last_arg()","rbreadline#rl_yank_nth_arg()","rbreadline#rl_yank_nth_arg_internal()","rbreadline#rl_yank_pop()","rbreadline#save_tty_chars()","rbreadline#set_completion_defaults()","rbreadline#sh_set_lines_and_columns()","readline::history::shift()","readline::history::shift()","readline::history::size()","readline::history::size()","rbreadline#space_to_eol()","rbreadline#stat_char()","rbreadline#stifle_history()","rbreadline#tgetflag()","readline::history::to_s()","readline::history::to_s()","rbreadline#trans()","rbreadline#unstifle_history()","rbreadline#update_line()","rbreadline#using_history()","readline::vi_editing_mode()","rbreadline#vis_chars()","rbreadline#vis_line()","rbreadline#vis_llen()","rbreadline#vis_pos()","rbreadline#w_offset()","rbreadline#where_history()","rbreadline#whitespace()","","",""],"info":[["Fixnum","","Fixnum.html","",""],["RbReadline","","RbReadline.html","",""],["RbReadline::Win32API","","RbReadline/Win32API.html","",""],["Readline","","Readline.html","","<p>readline.rb – GNU Readline module Copyright (C) 1997-2001  Shugo Maeda\n<p>Ruby translation by Park Heesob …\n"],["Readline::FILENAME_COMPLETION_PROC","","Readline/FILENAME_COMPLETION_PROC.html","","<p>The Fcomp class provided to encapsulate typical filename completion\nprocedure. You will not typically …\n"],["Readline::Fcomp","","Readline/Fcomp.html","","<p>The Fcomp class provided to encapsulate typical filename completion\nprocedure. You will not typically …\n"],["Readline::History","","Readline/History.html","","<p>The History class encapsulates a history of all commands entered by users\nat the prompt, providing an …\n"],["Readline::History","","Readline/History.html","","<p>The History class encapsulates a history of all commands entered by users\nat the prompt, providing an …\n"],["Readline::USERNAME_COMPLETION_PROC","","Readline/USERNAME_COMPLETION_PROC.html","","<p>The Ucomp class provided to encapsulate typical filename completion\nprocedure. You will not typically …\n"],["Readline::Ucomp","","Readline/Ucomp.html","","<p>The Ucomp class provided to encapsulate typical filename completion\nprocedure. You will not typically …\n"],["<<","Readline::History","Readline/History.html#method-c-3C-3C","(str)","<p>Synonym for Readline.add_history.\n"],["<<","Readline::History","Readline/History.html#method-c-3C-3C","(str)","<p>Synonym for Readline.add_history.\n"],["Call","RbReadline::Win32API","RbReadline/Win32API.html#method-i-Call","(*args)",""],["[]","Readline::History","Readline/History.html#method-c-5B-5D","(index)","<p>Returns the command that was entered at the specified <code>index</code> in\nthe history buffer.\n<p>Raises an IndexError …\n"],["[]","Readline::History","Readline/History.html#method-c-5B-5D","(index)","<p>Returns the command that was entered at the specified <code>index</code> in\nthe history buffer.\n<p>Raises an IndexError …\n"],["[]=","Readline::History","Readline/History.html#method-c-5B-5D-3D","(index,str)","<p>Sets the command <code>str</code> at the given index in the history buffer.\n<p>You can only replace an existing entry. …\n"],["[]=","Readline::History","Readline/History.html#method-c-5B-5D-3D","(index,str)","<p>Sets the command <code>str</code> at the given index in the history buffer.\n<p>You can only replace an existing entry. …\n"],["__rl_fix_point","RbReadline","RbReadline.html#method-i-__rl_fix_point","(x)","<p>Fix up point so that it is within the line boundaries after killing\n\n<pre>text.  If FIX_MARK_TOO is non-zero, ...</pre>\n"],["_extract_last_quote","RbReadline","RbReadline.html#method-i-_extract_last_quote","(string, quote_char)",""],["_rl_abort_internal","RbReadline","RbReadline.html#method-i-_rl_abort_internal","()","<p>How to abort things.\n"],["_rl_adjust_point","RbReadline","RbReadline.html#method-i-_rl_adjust_point","(string, point)","<p>adjust pointed byte and find mbstate of the point of string.\n\n<pre>adjusted point will be point &lt;= adjusted_point, ...</pre>\n"],["_rl_any_typein","RbReadline","RbReadline.html#method-i-_rl_any_typein","()",""],["_rl_arg_dispatch","RbReadline","RbReadline.html#method-i-_rl_arg_dispatch","(cxt, c)","<p>Process C as part of the current numeric argument.  Return -1 if the\n\n<pre>argument should be aborted, 0 if ...</pre>\n"],["_rl_arg_getchar","RbReadline","RbReadline.html#method-i-_rl_arg_getchar","()",""],["_rl_arg_init","RbReadline","RbReadline.html#method-i-_rl_arg_init","()",""],["_rl_arg_overflow","RbReadline","RbReadline.html#method-i-_rl_arg_overflow","()",""],["_rl_backspace","RbReadline","RbReadline.html#method-i-_rl_backspace","(count)","<p>Move the cursor back.\n"],["_rl_bind_tty_special_chars","RbReadline","RbReadline.html#method-i-_rl_bind_tty_special_chars","(kmap)",""],["_rl_char_search","RbReadline","RbReadline.html#method-i-_rl_char_search","(count, fdir, bdir)",""],["_rl_char_search_internal","RbReadline","RbReadline.html#method-i-_rl_char_search_internal","(count, dir, smbchar, len)",""],["_rl_char_value","RbReadline","RbReadline.html#method-i-_rl_char_value","(buf,ind)",""],["_rl_clean_up_for_exit","RbReadline","RbReadline.html#method-i-_rl_clean_up_for_exit","()",""],["_rl_clear_screen","RbReadline","RbReadline.html#method-i-_rl_clear_screen","()",""],["_rl_clear_to_eol","RbReadline","RbReadline.html#method-i-_rl_clear_to_eol","(count)","<p>Clear to the end of the line.  COUNT is the minimum\n\n<pre>number of character spaces to clear,</pre>\n"],["_rl_col_width","RbReadline","RbReadline.html#method-i-_rl_col_width","(string,start,_end)",""],["_rl_compare_chars","RbReadline","RbReadline.html#method-i-_rl_compare_chars","(buf1, pos1, buf2, pos2)","<p>compare the specified two characters. If the characters matched,\n\n<pre>return true. Otherwise return false.</pre>\n"],["_rl_control_keypad","RbReadline","RbReadline.html#method-i-_rl_control_keypad","(on)",""],["_rl_copy_to_kill_ring","RbReadline","RbReadline.html#method-i-_rl_copy_to_kill_ring","(text, append)","<p>Add TEXT to the kill ring, allocating a new kill ring slot as necessary.\n\n<pre>This uses TEXT directly, so the ...</pre>\n"],["_rl_current_display_line","RbReadline","RbReadline.html#method-i-_rl_current_display_line","()","<p>return the `current display line&#39; of the cursor – the number of lines\nto\n\n<pre>move up to get to the first ...</pre>\n"],["_rl_dispatch","RbReadline","RbReadline.html#method-i-_rl_dispatch","(key, map)","<p>Do the command associated with KEY in MAP.\n\n<pre>If the associated command is really a keymap, then read\nanother ...</pre>\n"],["_rl_dispatch_subseq","RbReadline","RbReadline.html#method-i-_rl_dispatch_subseq","(key, map, got_subseq)",""],["_rl_enable_meta_key","RbReadline","RbReadline.html#method-i-_rl_enable_meta_key","()",""],["_rl_erase_at_end_of_line","RbReadline","RbReadline.html#method-i-_rl_erase_at_end_of_line","(l)","<p>Quick redisplay hack when erasing characters at the end of the line.\n"],["_rl_erase_entire_line","RbReadline","RbReadline.html#method-i-_rl_erase_entire_line","()",""],["_rl_find_completion_word","RbReadline","RbReadline.html#method-i-_rl_find_completion_word","()",""],["_rl_find_next_mbchar","RbReadline","RbReadline.html#method-i-_rl_find_next_mbchar","(string, seed, count, flags)","<p>Find next `count&#39; characters started byte point of the specified seed.\n\n<pre>If flags is MB_FIND_NONZERO, ...</pre>\n"],["_rl_find_prev_mbchar","RbReadline","RbReadline.html#method-i-_rl_find_prev_mbchar","(string, seed, flags)","<p>Find previous character started byte point of the specified seed.\n\n<pre>Returned point will be point &lt;= seed. ...</pre>\n"],["_rl_fix_point","RbReadline","RbReadline.html#method-i-_rl_fix_point","(fix_mark_too)",""],["_rl_get_char_len","RbReadline","RbReadline.html#method-i-_rl_get_char_len","(src)","<p>return the number of bytes parsed from the multibyte sequence starting at\nsrc, if a non-L&#39;0&#39; …\n"],["_rl_get_screen_size","RbReadline","RbReadline.html#method-i-_rl_get_screen_size","(tty, ignore_env)","<p>Get readline&#39;s idea of the screen size.  TTY is a file descriptor open\n\n<pre>to the terminal.  If IGNORE_ENV ...</pre>\n"],["_rl_history_set_point","RbReadline","RbReadline.html#method-i-_rl_history_set_point","()",""],["_rl_init_eightbit","RbReadline","RbReadline.html#method-i-_rl_init_eightbit","()",""],["_rl_init_line_state","RbReadline","RbReadline.html#method-i-_rl_init_line_state","()",""],["_rl_init_terminal_io","RbReadline","RbReadline.html#method-i-_rl_init_terminal_io","(terminal_name)",""],["_rl_input_available","RbReadline","RbReadline.html#method-i-_rl_input_available","()",""],["_rl_insert_char","RbReadline","RbReadline.html#method-i-_rl_insert_char","(count, c)","<p>Insert the character C at the current location, moving point forward.\n\n<pre>If C introduces a multibyte sequence, ...</pre>\n"],["_rl_insert_next","RbReadline","RbReadline.html#method-i-_rl_insert_next","(count)","<p>Insert the next typed character verbatim.\n"],["_rl_insert_typein","RbReadline","RbReadline.html#method-i-_rl_insert_typein","(c)",""],["_rl_internal_char_cleanup","RbReadline","RbReadline.html#method-i-_rl_internal_char_cleanup","()",""],["_rl_internal_pager","RbReadline","RbReadline.html#method-i-_rl_internal_pager","(lines)",""],["_rl_is_mbchar_matched","RbReadline","RbReadline.html#method-i-_rl_is_mbchar_matched","(string, seed, _end, mbchar, length)",""],["_rl_isearch_cleanup","RbReadline","RbReadline.html#method-i-_rl_isearch_cleanup","(cxt, r)",""],["_rl_isearch_dispatch","RbReadline","RbReadline.html#method-i-_rl_isearch_dispatch","(cxt, c)","<p>Process just-read character C according to isearch context CXT.  Return\n\n<pre>-1 if the caller should just free ...</pre>\n"],["_rl_isearch_fini","RbReadline","RbReadline.html#method-i-_rl_isearch_fini","(cxt)",""],["_rl_isearch_init","RbReadline","RbReadline.html#method-i-_rl_isearch_init","(direction)",""],["_rl_make_prompt_for_search","RbReadline","RbReadline.html#method-i-_rl_make_prompt_for_search","(pchar)",""],["_rl_move_cursor_relative","RbReadline","RbReadline.html#method-i-_rl_move_cursor_relative","(new, data, start=0)","<p>Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.\n\n<pre>(Well, when we don&#39;t have multibyte ...</pre>\n"],["_rl_move_vert","RbReadline","RbReadline.html#method-i-_rl_move_vert","(to)","<p>PWP: move the cursor up or down.\n"],["_rl_nsearch_abort","RbReadline","RbReadline.html#method-i-_rl_nsearch_abort","(cxt)",""],["_rl_nsearch_cleanup","RbReadline","RbReadline.html#method-i-_rl_nsearch_cleanup","(cxt, r)",""],["_rl_nsearch_dispatch","RbReadline","RbReadline.html#method-i-_rl_nsearch_dispatch","(cxt, c)","<p>Process just-read character C according to search context CXT.  Return -1\n\n<pre>if the caller should abort the ...</pre>\n"],["_rl_nsearch_dosearch","RbReadline","RbReadline.html#method-i-_rl_nsearch_dosearch","(cxt)","<p>Perform one search according to CXT, using NONINC_SEARCH_STRING.  Return\n\n<pre>-1 if the search should be aborted, ...</pre>\n"],["_rl_nsearch_init","RbReadline","RbReadline.html#method-i-_rl_nsearch_init","(dir, pchar)",""],["_rl_output_some_chars","RbReadline","RbReadline.html#method-i-_rl_output_some_chars","(string,start,count)","<p>Write COUNT characters from STRING to the output stream.\n"],["_rl_overwrite_char","RbReadline","RbReadline.html#method-i-_rl_overwrite_char","(count, c)","<p>Overwrite the character at point (or next COUNT characters) with C.\n\n<pre>If C introduces a multibyte character ...</pre>\n"],["_rl_overwrite_rubout","RbReadline","RbReadline.html#method-i-_rl_overwrite_rubout","(count, key)","<p>This is different from what vi does, so the code&#39;s not shared.  Emacs\n\n<pre>rubout in overwrite mode has ...</pre>\n"],["_rl_read_init_file","RbReadline","RbReadline.html#method-i-_rl_read_init_file","(filename, include_level)",""],["_rl_read_mbchar","RbReadline","RbReadline.html#method-i-_rl_read_mbchar","(mbchar, size)","<p>read multibyte char\n"],["_rl_read_mbstring","RbReadline","RbReadline.html#method-i-_rl_read_mbstring","(first, mb, mlen)","<p>Read a multibyte-character string whose first character is FIRST into\n\n<pre>the buffer MB of length MLEN.  Returns ...</pre>\n"],["_rl_redisplay_after_sigwinch","RbReadline","RbReadline.html#method-i-_rl_redisplay_after_sigwinch","()","<p>Redisplay the current line after a SIGWINCH is received.\n"],["_rl_replace_text","RbReadline","RbReadline.html#method-i-_rl_replace_text","(text, start, _end)","<p>Replace the contents of the line buffer between START and END with\n\n<pre>TEXT.  The operation is undoable.  ...</pre>\n"],["_rl_reset_argument","RbReadline","RbReadline.html#method-i-_rl_reset_argument","()","<p>Create a default argument.\n"],["_rl_rubout_char","RbReadline","RbReadline.html#method-i-_rl_rubout_char","(count, key)",""],["_rl_scxt_alloc","RbReadline","RbReadline.html#method-i-_rl_scxt_alloc","(type, flags)",""],["_rl_search_getchar","RbReadline","RbReadline.html#method-i-_rl_search_getchar","(cxt)",""],["_rl_set_insert_mode","RbReadline","RbReadline.html#method-i-_rl_set_insert_mode","(im, force)","<p>Function for the rest of the library to use to set insert/overwrite mode.\n"],["_rl_set_mark_at_pos","RbReadline","RbReadline.html#method-i-_rl_set_mark_at_pos","(position)","<p>Set the mark at POSITION.\n"],["_rl_start_using_history","RbReadline","RbReadline.html#method-i-_rl_start_using_history","()","<p>Set the history pointer back to the last entry in the history.\n"],["_rl_strip_prompt","RbReadline","RbReadline.html#method-i-_rl_strip_prompt","(pmt)",""],["_rl_subseq_getchar","RbReadline","RbReadline.html#method-i-_rl_subseq_getchar","(key)",""],["_rl_to_lower","RbReadline","RbReadline.html#method-i-_rl_to_lower","(char)",""],["_rl_unget_char","RbReadline","RbReadline.html#method-i-_rl_unget_char","(key)","<p>Stuff KEY into the <strong>front</strong> of the input buffer.\n\n<pre>Returns non-zero if successful, zero if there is\nno space ...</pre>\n"],["_rl_update_final","RbReadline","RbReadline.html#method-i-_rl_update_final","()",""],["_rl_vi_done_inserting","RbReadline","RbReadline.html#method-i-_rl_vi_done_inserting","()",""],["_rl_vi_initialize_line","RbReadline","RbReadline.html#method-i-_rl_vi_initialize_line","()",""],["_rl_vi_reset_last","RbReadline","RbReadline.html#method-i-_rl_vi_reset_last","()",""],["_rl_vi_save_insert","RbReadline","RbReadline.html#method-i-_rl_vi_save_insert","(up)",""],["_rl_vi_textmod_command","RbReadline","RbReadline.html#method-i-_rl_vi_textmod_command","(c)","<p>Is the command C a VI mode text modification command?\n"],["_rl_walphabetic","RbReadline","RbReadline.html#method-i-_rl_walphabetic","(c)",""],["add_history","RbReadline","RbReadline.html#method-i-add_history","(string)","<p>Place STRING at the end of the history list.  The data field\n\n<pre>is  set to NULL.</pre>\n"],["alloc_history_entry","RbReadline","RbReadline.html#method-i-alloc_history_entry","(string, ts)",""],["alloc_undo_entry","RbReadline","RbReadline.html#method-i-alloc_undo_entry","(what, start, _end, text)",""],["append_to_match","RbReadline","RbReadline.html#method-i-append_to_match","(text, delimiter, quote_char, nontrivial_match)","<p>Append any necessary closing quote and a separator character to the\njust-inserted match.  If the user …\n"],["basic_quote_characters","Readline","Readline.html#method-c-basic_quote_characters","()","<p>Returns the list of quote characters that can cause a word break. The\ndefault is “&#39;&quot;” …\n"],["basic_quote_characters=","Readline","Readline.html#method-c-basic_quote_characters-3D","(str)","<p>Sets the list of quote characters that can cause a word break.\n"],["basic_word_break_characters","Readline","Readline.html#method-c-basic_word_break_characters","()","<p>Returns the character string that signal a break between words for the\ncompletion proc. The default is …\n"],["basic_word_break_characters=","Readline","Readline.html#method-c-basic_word_break_characters-3D","(str)","<p>Sets the character string that signal a break between words for the\ncompletion proc.\n"],["bind_arrow_keys","RbReadline","RbReadline.html#method-i-bind_arrow_keys","()","<p>Try and bind the common arrow key prefixes after giving termcap and\n\n<pre>the inputrc file a chance to bind ...</pre>\n"],["bind_arrow_keys_internal","RbReadline","RbReadline.html#method-i-bind_arrow_keys_internal","(map)","<p>Bind some common arrow key sequences in MAP.\n"],["bind_termcap_arrow_keys","RbReadline","RbReadline.html#method-i-bind_termcap_arrow_keys","(map)","<p>Bind the arrow key sequences from the termcap description in MAP.\n"],["block_sigint","RbReadline","RbReadline.html#method-i-block_sigint","()",""],["call","RbReadline::Win32API","RbReadline/Win32API.html#method-i-call","(*args)",""],["call","Readline::Fcomp","Readline/Fcomp.html#method-c-call","(str)",""],["call","Readline::Fcomp","Readline/Fcomp.html#method-c-call","(str)",""],["call","Readline::Ucomp","Readline/Ucomp.html#method-c-call","(str)",""],["call","Readline::Ucomp","Readline/Ucomp.html#method-c-call","(str)",""],["clear_history","RbReadline","RbReadline.html#method-i-clear_history","()",""],["completer_quote_characters","Readline","Readline.html#method-c-completer_quote_characters","()","<p>Returns the list of characters that can be used to quote a substring of the\nline, i.e. a group of characters …\n"],["completer_quote_characters=","Readline","Readline.html#method-c-completer_quote_characters-3D","(str)","<p>Sets the list of characters that can be used to quote a substring of the\nline, i.e. a group of characters …\n"],["completer_word_break_characters","Readline","Readline.html#method-c-completer_word_break_characters","()","<p>Returns the character string that signal the start or end of a word for the\ncompletion proc.\n"],["completer_word_break_characters=","Readline","Readline.html#method-c-completer_word_break_characters-3D","(str)","<p>Sets the character string that signal the start or end of a word for the\ncompletion proc.\n"],["completion_append_character","Readline","Readline.html#method-c-completion_append_character","()","<p>Returns the character that is automatically appended after the\nReadline.completion_proc method is called. …\n"],["completion_append_character=","Readline","Readline.html#method-c-completion_append_character-3D","(char)","<p>Sets the character that is automatically appended after the\nReadline.completion_proc method is called. …\n"],["completion_case_fold","Readline","Readline.html#method-c-completion_case_fold","()","<p>Returns whether or not the completion proc is case sensitive. The default\nis false, i.e. completion procs …\n"],["completion_case_fold=","Readline","Readline.html#method-c-completion_case_fold-3D","(bool)","<p>Sets whether or not the completion proc should ignore case sensitivity. The\ndefault is false, i.e. completion …\n"],["completion_proc","Readline","Readline.html#method-c-completion_proc","()","<p>Returns the current auto-completion procedure.\n"],["completion_proc=","Readline","Readline.html#method-c-completion_proc-3D","(proc)","<p>Sets the auto-completion procedure (i.e. tab auto-complete).\n<p>The <code>proc</code> argument is typically a Proc object. …\n"],["compute_lcd_of_matches","RbReadline","RbReadline.html#method-i-compute_lcd_of_matches","(match_list, matches, text)","<p>Find the common prefix of the list of matches, and put it into\n\n<pre>matches[0].</pre>\n"],["cr","RbReadline","RbReadline.html#method-i-cr","()","<p>Move to the start of the current line.\n"],["cr_faster","RbReadline","RbReadline.html#method-i-cr_faster","(new, cur)",""],["ctrl_char","RbReadline","RbReadline.html#method-i-ctrl_char","(c)",""],["current_history","RbReadline","RbReadline.html#method-i-current_history","()","<p>Return the history entry at the current position, as determined by\n\n<pre>history_offset.  If there is no entry ...</pre>\n"],["delete_at","Readline::History","Readline/History.html#method-c-delete_at","(index)","<p>Deletes an entry from the histoyr buffer at the specified\n<code>index</code>.\n"],["delete_at","Readline::History","Readline/History.html#method-c-delete_at","(index)","<p>Deletes an entry from the histoyr buffer at the specified\n<code>index</code>.\n"],["delete_chars","RbReadline","RbReadline.html#method-i-delete_chars","(count)","<p>Delete COUNT characters from the display line.\n"],["display_matches","RbReadline","RbReadline.html#method-i-display_matches","(matches)","<p>Display MATCHES, a list of matching filenames in argv format.  This handles\nthe simple case – a single …\n"],["each","Readline::History","Readline/History.html#method-c-each","()","<p>Iterates over each entry in the history buffer.\n"],["each","Readline::History","Readline/History.html#method-c-each","()","<p>Iterates over each entry in the history buffer.\n"],["emacs_editing_mode","Readline","Readline.html#method-c-emacs_editing_mode","()","<p>Sets emacs editing mode\n"],["empty?","Readline::History","Readline/History.html#method-c-empty-3F","()","<p>Returns a bolean value indicating whether or not the history buffer is\nempty.\n"],["empty?","Readline::History","Readline/History.html#method-c-empty-3F","()","<p>Returns a bolean value indicating whether or not the history buffer is\nempty.\n"],["endsrch_char","RbReadline","RbReadline.html#method-i-endsrch_char","(c)",""],["expand_prompt","RbReadline","RbReadline.html#method-i-expand_prompt","(pmt)","<p>Current implementation:\n\n<pre> \\001 (^A) start non-visible characters\n \\002 (^B) end non-visible characters ...</pre>\n"],["filename_quote_characters","Readline","Readline.html#method-c-filename_quote_characters","()","<p>Returns the character string used to indicate quotes for the filename\ncompletion of user input.\n"],["filename_quote_characters=","Readline","Readline.html#method-c-filename_quote_characters-3D","(str)","<p>Sets the character string of one or more characters that indicate quotes\nfor the filename completion …\n"],["fnprint","RbReadline","RbReadline.html#method-i-fnprint","(to_print)",""],["fnwidth","RbReadline","RbReadline.html#method-i-fnwidth","(string)","<p>Compute width of STRING when displayed on screen by print_filename\n"],["gen_completion_matches","RbReadline","RbReadline.html#method-i-gen_completion_matches","(text, start, _end, our_func, found_quote, quote_char)",""],["get_term_capabilities","RbReadline","RbReadline.html#method-i-get_term_capabilities","(buffer)",""],["get_y_or_n","RbReadline","RbReadline.html#method-i-get_y_or_n","(for_pager)","<p>The user must press “y” or “n”. Non-zero return means “y” pressed.\n"],["handle_parser_directive","RbReadline","RbReadline.html#method-i-handle_parser_directive","(statement)","<p>Handle a parser directive.  STATEMENT is the line of the directive\n\n<pre>without any leading `$&#39;.</pre>\n"],["hist_inittime","RbReadline","RbReadline.html#method-i-hist_inittime","()",""],["history_arg_extract","RbReadline","RbReadline.html#method-i-history_arg_extract","(first, last, string)",""],["history_get","RbReadline","RbReadline.html#method-i-history_get","(offset)","<p>Return the history entry which is logically at OFFSET in the history array.\n\n<pre>OFFSET is relative to history_base.</pre>\n"],["history_is_stifled","RbReadline","RbReadline.html#method-i-history_is_stifled","()",""],["history_list","RbReadline","RbReadline.html#method-i-history_list","()",""],["history_search_pos","RbReadline","RbReadline.html#method-i-history_search_pos","(string, dir, pos)","<p>Search for STRING in the history list.  DIR is &lt; 0 for searching\n\n<pre>backwards.  POS is an absolute index ...</pre>\n"],["history_search_prefix","RbReadline","RbReadline.html#method-i-history_search_prefix","(string, direction)","<p>Do an anchored search for string through the history in DIRECTION.\n"],["history_set_pos","RbReadline","RbReadline.html#method-i-history_set_pos","(pos)","<p>Make the current history item be the one at POS, an absolute index.\n\n<pre>Returns zero if POS is out of range, ...</pre>\n"],["ibuffer_space","RbReadline","RbReadline.html#method-i-ibuffer_space","()","<p>Return the amount of space available in the buffer for stuffing\n\n<pre>characters.</pre>\n"],["init_line_structures","RbReadline","RbReadline.html#method-i-init_line_structures","(minsize)","<p>Initialize the VISIBLE_LINE and INVISIBLE_LINE arrays, and their associated\n\n<pre>arrays of line break markers. ...</pre>\n"],["input=","Readline","Readline.html#method-c-input-3D","(input)","<p>Sets the input stream (an IO object) for readline interaction. The default\nis <code>$stdin</code>.\n"],["insert_all_matches","RbReadline","RbReadline.html#method-i-insert_all_matches","(matches, point, qc)",""],["insert_match","RbReadline","RbReadline.html#method-i-insert_match","(match, start, mtype, qc)",""],["insert_some_chars","RbReadline","RbReadline.html#method-i-insert_some_chars","(string, count, col)","<p>Insert COUNT characters from STRING to the output stream at column COL.\n"],["inv_line","RbReadline","RbReadline.html#method-i-inv_line","(line)",""],["inv_llen","RbReadline","RbReadline.html#method-i-inv_llen","(l)",""],["isascii","RbReadline","RbReadline.html#method-i-isascii","(c)",""],["isprint","RbReadline","RbReadline.html#method-i-isprint","(c)",""],["length","Readline::History","Readline/History.html#method-c-length","()","<p>Returns the length of the history buffer.\n"],["length","Readline::History","Readline/History.html#method-c-length","()","<p>Returns the length of the history buffer.\n"],["line_buffer","Readline","Readline.html#method-c-line_buffer","()","<p>Returns current line buffer\n"],["m_offset","RbReadline","RbReadline.html#method-i-m_offset","(margin, offset)",""],["make_history_line_current","RbReadline","RbReadline.html#method-i-make_history_line_current","(entry)","<p>Make the data from the history entry ENTRY be the contents of the\n\n<pre>current line.  This doesn&#39;t do anything ...</pre>\n"],["make_quoted_replacement","RbReadline","RbReadline.html#method-i-make_quoted_replacement","(match, mtype, qc)",""],["meta_char","RbReadline","RbReadline.html#method-i-meta_char","(c)",""],["new","RbReadline::Win32API","RbReadline/Win32API.html#method-c-new","(dllname, func, import, export = \"0\", calltype = :stdcall)",""],["next_history","RbReadline","RbReadline.html#method-i-next_history","()","<p>Move history_offset forward to the next history entry, and return\n\n<pre>a pointer to that entry.  If there is ...</pre>\n"],["no_terminal?","RbReadline","RbReadline.html#method-i-no_terminal-3F","()",""],["noninc_dosearch","RbReadline","RbReadline.html#method-i-noninc_dosearch","(string, dir)","<p>Search for a line in the history containing STRING.  If DIR is &lt; 0, the\n\n<pre>search is backwards through ...</pre>\n"],["noninc_search","RbReadline","RbReadline.html#method-i-noninc_search","(dir, pchar)","<p>Search non-interactively through the history list.  DIR &lt; 0 means to\n\n<pre>search backwards through the history ...</pre>\n"],["noninc_search_from_pos","RbReadline","RbReadline.html#method-i-noninc_search_from_pos","(string, pos, dir)","<p>Search the history list for STRING starting at absolute history position\n\n<pre>POS.  If STRING begins with `^&#39;, ...</pre>\n"],["ord","Fixnum","Fixnum.html#method-i-ord","()",""],["output=","Readline","Readline.html#method-c-output-3D","(output)","<p>Sets the output stream (an IO object) for readline interaction. The default\nis <code>$stdout</code>.\n"],["parser_else","RbReadline","RbReadline.html#method-i-parser_else","(args)","<p>Invert the current parser state if there is anything on the stack.\n"],["parser_endif","RbReadline","RbReadline.html#method-i-parser_endif","(args)","<p>Terminate a conditional, popping the value of\n\n<pre>_rl_parsing_conditionalized_out from the stack.</pre>\n"],["parser_if","RbReadline","RbReadline.html#method-i-parser_if","(args)","<p>Push _rl_parsing_conditionalized_out, and set parser state based\n\n<pre>on ARGS.</pre>\n"],["parser_include","RbReadline","RbReadline.html#method-i-parser_include","(args)",""],["path_isdir","RbReadline","RbReadline.html#method-i-path_isdir","(filename)",""],["point","Readline","Readline.html#method-c-point","()","<p>Returns the current offset in the current input line.\n"],["pop","Readline::History","Readline/History.html#method-c-pop","()","<p>Removes and returns the last element from the history buffer.\n"],["pop","Readline::History","Readline/History.html#method-c-pop","()","<p>Removes and returns the last element from the history buffer.\n"],["postprocess_matches","RbReadline","RbReadline.html#method-i-postprocess_matches","(matchesp, matching_filenames)",""],["prepare_terminal_settings","RbReadline","RbReadline.html#method-i-prepare_terminal_settings","(meta_flag)",""],["previous_history","RbReadline","RbReadline.html#method-i-previous_history","()","<p>Back up history_offset to the previous history entry, and return\n\n<pre>a pointer to that entry.  If there is ...</pre>\n"],["print_filename","RbReadline","RbReadline.html#method-i-print_filename","(to_print, full_pathname)","<p>Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we\n\n<pre>are using it, check for and output ...</pre>\n"],["printable_part","RbReadline","RbReadline.html#method-i-printable_part","(pathname)","<p>Return the portion of PATHNAME that should be output when listing\n\n<pre>possible completions.  If we are hacking ...</pre>\n"],["prompt_ending_index","RbReadline","RbReadline.html#method-i-prompt_ending_index","()","<p>_rl_last_c_pos is an absolute cursor position in multibyte locales and a\n\n<pre>buffer index in others.  This ...</pre>\n\n"],["push","Readline::History","Readline/History.html#method-c-push","(*args)","<p>Pushes a list of <code>args</code> onto the history buffer.\n"],["push","Readline::History","Readline/History.html#method-c-push","(*args)","<p>Pushes a list of <code>args</code> onto the history buffer.\n"],["rb_remove_history","Readline::History","Readline/History.html#method-c-rb_remove_history","(index)","<p>Internal function that removes the item at <code>index</code> from the\nhistory buffer, performing necessary duplication …\n"],["rb_remove_history","Readline::History","Readline/History.html#method-c-rb_remove_history","(index)","<p>Internal function that removes the item at <code>index</code> from the\nhistory buffer, performing necessary duplication …\n"],["readline","RbReadline","RbReadline.html#method-i-readline","(prompt)","<p>Read a line of input.  Prompt with PROMPT.  An empty PROMPT means\n\n<pre>none.  A return value of NULL means ...</pre>\n"],["readline","Readline","Readline.html#method-i-readline","(prompt = \"\", add_history = nil)","<p>Begins an interactive terminal process using <code>prompt</code> as the\ncommand prompt that users see when they type …\n"],["readline","Readline","Readline.html#method-c-readline","(prompt = \"\", add_history = nil)","<p>Begins an interactive terminal process using <code>prompt</code> as the\ncommand prompt that users see when they type …\n"],["readline_attempted_completion_function","Readline","Readline.html#method-c-readline_attempted_completion_function","(text,start,_end)","<p>Returns nil if no matches are found or an array of strings:\n\n<pre>[0] is the replacement for text\n[1..n] the ...</pre>\n"],["readline_default_bindings","RbReadline","RbReadline.html#method-i-readline_default_bindings","()","<p>If this system allows us to look at the values of the regular\n\n<pre>input editing characters, then bind them ...</pre>\n"],["readline_initialize_everything","RbReadline","RbReadline.html#method-i-readline_initialize_everything","()","<p>Initialize the entire state of the world.\n"],["readline_internal","RbReadline","RbReadline.html#method-i-readline_internal","()","<p>Read a line of input from the global rl_instream, doing output on\n\n<pre>the global rl_outstream.\nIf rl_prompt ...</pre>\n"],["readline_internal_charloop","RbReadline","RbReadline.html#method-i-readline_internal_charloop","()",""],["readline_internal_setup","RbReadline","RbReadline.html#method-i-readline_internal_setup","()",""],["readline_internal_teardown","RbReadline","RbReadline.html#method-i-readline_internal_teardown","(eof)",""],["redraw_prompt","RbReadline","RbReadline.html#method-i-redraw_prompt","(t)","<p>Redraw the last line of a multi-line prompt that may possibly contain\nterminal escape sequences.  Called …\n"],["release_sigint","RbReadline","RbReadline.html#method-i-release_sigint","()",""],["remove_duplicate_matches","RbReadline","RbReadline.html#method-i-remove_duplicate_matches","(matches)","<p>Filter out duplicates in MATCHES.  This frees up the strings in\n\n<pre>MATCHES.</pre>\n"],["remove_history","RbReadline","RbReadline.html#method-i-remove_history","(which)","<p>Remove history element WHICH from the history.  The removed\n\n<pre>element is returned to you so you can free ...</pre>\n"],["replace_history_data","RbReadline","RbReadline.html#method-i-replace_history_data","(which,old, new)","<p>Replace the DATA in the specified history entries, replacing OLD with\n\n<pre>NEW.  WHICH says which one(s) to ...</pre>\n"],["replace_history_entry","RbReadline","RbReadline.html#method-i-replace_history_entry","(which, line, data)","<p>Make the history entry at WHICH have LINE and DATA.  This returns\n\n<pre>the old entry so you can dispose of ...</pre>\n"],["retry_if_interrupted","RbReadline","RbReadline.html#method-i-retry_if_interrupted","(&block)",""],["rl_abort","RbReadline","RbReadline.html#method-i-rl_abort","(count, key)",""],["rl_add_undo","RbReadline","RbReadline.html#method-i-rl_add_undo","(what, start, _end, text)","<p>Remember how to undo something.  Concatenate some undos if that\n\n<pre>seems right.</pre>\n\n"],["rl_alphabetic","RbReadline","RbReadline.html#method-i-rl_alphabetic","(c)",""],["rl_arrow_keys","RbReadline","RbReadline.html#method-i-rl_arrow_keys","(count, c)",""],["rl_backward","RbReadline","RbReadline.html#method-i-rl_backward","(count, key)","<p>Backwards compatibility.\n"],["rl_backward_byte","RbReadline","RbReadline.html#method-i-rl_backward_byte","(count, key)","<p>Move backward COUNT bytes.\n"],["rl_backward_char","RbReadline","RbReadline.html#method-i-rl_backward_char","(count, key)","<p>Move backward COUNT characters.\n"],["rl_backward_char_search","RbReadline","RbReadline.html#method-i-rl_backward_char_search","(count, key)",""],["rl_backward_kill_line","RbReadline","RbReadline.html#method-i-rl_backward_kill_line","(direction, ignore)","<p>Kill backwards to the start of the line.  If DIRECTION is negative, kill\n\n<pre>forwards to the line end instead.</pre>\n"],["rl_backward_kill_word","RbReadline","RbReadline.html#method-i-rl_backward_kill_word","(count, ignore)","<p>Rubout the word before point, placing it on the kill ring.\n"],["rl_backward_word","RbReadline","RbReadline.html#method-i-rl_backward_word","(count, key)","<p>Move backward a word.  We do what Emacs does.  Handles multibyte chars.\n"],["rl_beg_of_line","RbReadline","RbReadline.html#method-i-rl_beg_of_line","(count, key)","<p>Move to the beginning of the line.\n"],["rl_begin_undo_group","RbReadline","RbReadline.html#method-i-rl_begin_undo_group","()","<p>Begin a group.  Subsequent undos are undone as an atomic operation.\n"],["rl_beginning_of_history","RbReadline","RbReadline.html#method-i-rl_beginning_of_history","(count, key)","<p>Meta-&lt; goes to the start of the history.\n"],["rl_bind_key","RbReadline","RbReadline.html#method-i-rl_bind_key","(key, function)","<p>Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range.\n"],["rl_bind_keyseq_if_unbound","RbReadline","RbReadline.html#method-i-rl_bind_keyseq_if_unbound","(keyseq, default_func)",""],["rl_bind_keyseq_if_unbound_in_map","RbReadline","RbReadline.html#method-i-rl_bind_keyseq_if_unbound_in_map","(keyseq, default_func, kmap)","<p>Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right\n\n<pre>now, this is always used to attempt ...</pre>\n"],["rl_bind_keyseq_in_map","RbReadline","RbReadline.html#method-i-rl_bind_keyseq_in_map","(keyseq, function, map)","<p>Bind the key sequence represented by the string KEYSEQ to\n\n<pre>FUNCTION.  This makes new keymaps as necessary. ...</pre>\n"],["rl_capitalize_word","RbReadline","RbReadline.html#method-i-rl_capitalize_word","(count, key)","<p>Upcase the first letter, downcase the rest.\n"],["rl_change_case","RbReadline","RbReadline.html#method-i-rl_change_case","(count, op)","<p>The meaty function.\n\n<pre>Change the case of COUNT words, performing OP on them.\nOP is one of UpCase, DownCase, ...</pre>\n"],["rl_char_search","RbReadline","RbReadline.html#method-i-rl_char_search","(count, key)",""],["rl_character_len","RbReadline","RbReadline.html#method-i-rl_character_len","(c, pos)",""],["rl_cleanup_after_signal","RbReadline","RbReadline.html#method-i-rl_cleanup_after_signal","()","<p>Clean up the terminal and readline state after catching a signal, before\n\n<pre>resending it to the calling application.</pre>\n"],["rl_clear_message","RbReadline","RbReadline.html#method-i-rl_clear_message","()","<p>How to clear things from the “echo-area”.\n"],["rl_clear_pending_input","RbReadline","RbReadline.html#method-i-rl_clear_pending_input","()","<p>Clear any pending input pushed with rl_execute_next()\n"],["rl_clear_screen","RbReadline","RbReadline.html#method-i-rl_clear_screen","(count, key)","<p>C-l typed to a line without quoting clears the screen, and then reprints\n\n<pre>the prompt and the current input ...</pre>\n"],["rl_clear_signals","RbReadline","RbReadline.html#method-i-rl_clear_signals","()",""],["rl_complete","RbReadline","RbReadline.html#method-i-rl_complete","(ignore, invoking_key)","<p>Complete the word at or before point.  You have supplied the function\n\n<pre>that does the initial simple matching ...</pre>\n"],["rl_complete_internal","RbReadline","RbReadline.html#method-i-rl_complete_internal","(what_to_do)","<p>Complete the word at or before point.\n\n<pre>WHAT_TO_DO says what to do with the completion.\n`?&#39; means list the ...</pre>\n"],["rl_completion_matches","RbReadline","RbReadline.html#method-i-rl_completion_matches","(text, entry_function)","<p>Return an array of (char *) which is a list of completions for TEXT.\n\n<pre>If there are no completions, return ...</pre>\n"],["rl_copy_text","RbReadline","RbReadline.html#method-i-rl_copy_text","(from, to)",""],["rl_crlf","RbReadline","RbReadline.html#method-i-rl_crlf","()","<p>Move to the start of the next line.\n"],["rl_delete","RbReadline","RbReadline.html#method-i-rl_delete","(count, key)","<p>Delete the character under the cursor.  Given a numeric argument,\n\n<pre>kill that many characters instead.</pre>\n"],["rl_delete_horizontal_space","RbReadline","RbReadline.html#method-i-rl_delete_horizontal_space","(count, ignore)","<p>Delete all spaces and tabs around point.\n"],["rl_delete_or_show_completions","RbReadline","RbReadline.html#method-i-rl_delete_or_show_completions","(count, key)","<p>Like the tcsh editing function delete-char-or-list.  The eof character\n\n<pre>is caught before this is invoked, ...</pre>\n"],["rl_delete_text","RbReadline","RbReadline.html#method-i-rl_delete_text","(from, to)","<p>Delete the string between FROM and TO.  FROM is inclusive, TO is not.\n\n<pre>Returns the number of characters ...</pre>\n"],["rl_deprep_terminal","RbReadline","RbReadline.html#method-i-rl_deprep_terminal","()","<p>Restore the terminal&#39;s normal settings and modes.\n"],["rl_digit_argument","RbReadline","RbReadline.html#method-i-rl_digit_argument","(ignore, key)","<p>Start a numeric argument with initial value KEY\n"],["rl_digit_loop","RbReadline","RbReadline.html#method-i-rl_digit_loop","()","<p>Handle C-u style numeric args, as well as M–, and M-digits.\n"],["rl_ding","RbReadline","RbReadline.html#method-i-rl_ding","()","<p>Ring the terminal bell.\n"],["rl_display_match_list","RbReadline","RbReadline.html#method-i-rl_display_match_list","(matches, len, max)","<p>A convenience function for displaying a list of strings in\n\n<pre>columnar format on readline&#39;s output stream. ...</pre>\n"],["rl_display_search","RbReadline","RbReadline.html#method-i-rl_display_search","(search_string, reverse_p, where)","<p>Display the current state of the search in the echo-area.\n\n<pre>SEARCH_STRING contains the string that is being ...</pre>\n"],["rl_do_lowercase_version","RbReadline","RbReadline.html#method-i-rl_do_lowercase_version","(ignore1, ignore2)","<p>What to do for some uppercase characters, like meta characters,\n\n<pre>and some characters appearing in emacs_ctlx_keymap. ...</pre>\n"],["rl_do_undo","RbReadline","RbReadline.html#method-i-rl_do_undo","()",""],["rl_downcase_word","RbReadline","RbReadline.html#method-i-rl_downcase_word","(count, key)","<p>Lowercase the word at point.\n"],["rl_emacs_editing_mode","RbReadline","RbReadline.html#method-i-rl_emacs_editing_mode","(count, key)",""],["rl_end_of_history","RbReadline","RbReadline.html#method-i-rl_end_of_history","(count, key)","<p>Meta-&gt; goes to the end of the history.  (The current line).\n"],["rl_end_of_line","RbReadline","RbReadline.html#method-i-rl_end_of_line","(count, key)","<p>Move to the end of the line.\n"],["rl_end_undo_group","RbReadline","RbReadline.html#method-i-rl_end_undo_group","()","<p>End an undo group started with rl_begin_undo_group ().\n"],["rl_exchange_point_and_mark","RbReadline","RbReadline.html#method-i-rl_exchange_point_and_mark","(count, key)","<p>Exchange the position of mark and point.\n"],["rl_execute_next","RbReadline","RbReadline.html#method-i-rl_execute_next","(c)","<p>Make C be the next command to be executed.\n"],["rl_expand_prompt","RbReadline","RbReadline.html#method-i-rl_expand_prompt","(prompt)","<p>*\n<p>Expand the prompt string into the various display components, if\n<p>necessary.\n"],["rl_extend_line_buffer","RbReadline","RbReadline.html#method-i-rl_extend_line_buffer","(len)","<p>Increase the size of RL_LINE_BUFFER until it has enough space to hold\n\n<pre>LEN characters.</pre>\n"],["rl_filename_completion_function","RbReadline","RbReadline.html#method-i-rl_filename_completion_function","(text, state)","<p>Okay, now we write the entry_function for filename completion.  In the\ngeneral case.  Note that completion …\n"],["rl_forced_update_display","RbReadline","RbReadline.html#method-i-rl_forced_update_display","()","<p>Actually update the display, period.\n"],["rl_forward","RbReadline","RbReadline.html#method-i-rl_forward","(count, key)","<p>Backwards compatibility.\n"],["rl_forward_byte","RbReadline","RbReadline.html#method-i-rl_forward_byte","(count, key)","<p>Move forward COUNT bytes.\n"],["rl_forward_char","RbReadline","RbReadline.html#method-i-rl_forward_char","(count, key)","<p>Move forward COUNT characters.\n"],["rl_forward_search_history","RbReadline","RbReadline.html#method-i-rl_forward_search_history","(sign, key)","<p>Search forwards through the history looking for a string which is typed\n\n<pre>interactively.  Start with the ...</pre>\n"],["rl_forward_word","RbReadline","RbReadline.html#method-i-rl_forward_word","(count, key)","<p>Move forward a word.  We do what Emacs does.  Handles multibyte chars.\n"],["rl_free_undo_list","RbReadline","RbReadline.html#method-i-rl_free_undo_list","()",""],["rl_function_of_keyseq","RbReadline","RbReadline.html#method-i-rl_function_of_keyseq","(keyseq, map, type)","<p>Return the function (or macro) definition which would be invoked via\n\n<pre>KEYSEQ if executed in MAP.  If MAP ...</pre>\n"],["rl_gather_tyi","RbReadline","RbReadline.html#method-i-rl_gather_tyi","()",""],["rl_generic_bind","RbReadline","RbReadline.html#method-i-rl_generic_bind","(type, keyseq, data, map)","<p>Bind the key sequence represented by the string KEYSEQ to\n\n<pre>the arbitrary pointer DATA.  TYPE says what ...</pre>\n"],["rl_get_char","RbReadline","RbReadline.html#method-i-rl_get_char","()","<p>Get a key from the buffer of characters to be read.\n\n<pre>Return the key in KEY.\nResult is KEY if there was ...</pre>\n"],["rl_get_keymap_name_from_edit_mode","RbReadline","RbReadline.html#method-i-rl_get_keymap_name_from_edit_mode","()",""],["rl_get_next_history","RbReadline","RbReadline.html#method-i-rl_get_next_history","(count, key)","<p>Move down to the next history line.\n"],["rl_get_previous_history","RbReadline","RbReadline.html#method-i-rl_get_previous_history","(count, key)","<p>Get the previous item out of our interactive history, making it the current\n\n<pre>line.  If there is no previous ...</pre>\n"],["rl_getc","RbReadline","RbReadline.html#method-i-rl_getc","(stream)",""],["rl_initialize","RbReadline","RbReadline.html#method-i-rl_initialize","()","<p>Initialize readline (and terminal if not already).\n"],["rl_insert","RbReadline","RbReadline.html#method-i-rl_insert","(count, c)",""],["rl_insert_comment","RbReadline","RbReadline.html#method-i-rl_insert_comment","(count, key)","<p>Turn the current line into a comment in shell history.\n\n<pre>A K*rn shell style function.</pre>\n"],["rl_insert_completions","RbReadline","RbReadline.html#method-i-rl_insert_completions","(ignore, invoking_key)",""],["rl_insert_text","RbReadline","RbReadline.html#method-i-rl_insert_text","(string)","<p>Insert a string of text into the line at point.  This is the only\n\n<pre>way that you should do insertion.  _rl_insert_char ...</pre>\n"],["rl_isstate","RbReadline","RbReadline.html#method-i-rl_isstate","(x)",""],["rl_kill_full_line","RbReadline","RbReadline.html#method-i-rl_kill_full_line","(count, ignore)","<p>Kill the whole line, no matter where point is.\n"],["rl_kill_line","RbReadline","RbReadline.html#method-i-rl_kill_line","(direction, ignore)","<p>Kill from here to the end of the line.  If DIRECTION is negative, kill\n\n<pre>back to the line start instead.</pre>\n"],["rl_kill_text","RbReadline","RbReadline.html#method-i-rl_kill_text","(from, to)","<p>The way to kill something.  This appends or prepends to the last\n\n<pre>kill, if the last command was a kill ...</pre>\n"],["rl_kill_word","RbReadline","RbReadline.html#method-i-rl_kill_word","(count, key)","<p>Delete the word at point, saving the text in the kill ring.\n"],["rl_line_buffer","RbReadline","RbReadline.html#method-i-rl_line_buffer","()",""],["rl_maybe_replace_line","RbReadline","RbReadline.html#method-i-rl_maybe_replace_line","()","<p>Perhaps put back the current line if it has changed.\n"],["rl_maybe_save_line","RbReadline","RbReadline.html#method-i-rl_maybe_save_line","()","<p>Save the current line in _rl_saved_line_for_history.\n"],["rl_maybe_unsave_line","RbReadline","RbReadline.html#method-i-rl_maybe_unsave_line","()","<p>Restore the _rl_saved_line_for_history if there is one.\n"],["rl_message","RbReadline","RbReadline.html#method-i-rl_message","(msg_buf)",""],["rl_modifying","RbReadline","RbReadline.html#method-i-rl_modifying","(start, _end)","<p>Save an undo entry for the text from START to END.\n"],["rl_named_function","RbReadline","RbReadline.html#method-i-rl_named_function","(name)",""],["rl_newline","RbReadline","RbReadline.html#method-i-rl_newline","(count, key)","<p>What to do when a NEWLINE is pressed.  We accept the whole line.\n\n<pre>KEY is the key that invoked this command. ...</pre>\n"],["rl_noninc_forward_search","RbReadline","RbReadline.html#method-i-rl_noninc_forward_search","(count, key)","<p>Search forward through the history list for a string.  If the vi-mode\n\n<pre>code calls this, KEY will be `?&#39;.</pre>\n"],["rl_noninc_reverse_search","RbReadline","RbReadline.html#method-i-rl_noninc_reverse_search","(count, key)","<p>Reverse search the history list for a string.  If the vi-mode code\n\n<pre>calls this, KEY will be `/&#39;.</pre>\n"],["rl_on_new_line","RbReadline","RbReadline.html#method-i-rl_on_new_line","()","<p>Tell the update routines that we have moved onto a new (empty) line.\n"],["rl_on_new_line_with_prompt","RbReadline","RbReadline.html#method-i-rl_on_new_line_with_prompt","()","<p>Tell the update routines that we have moved onto a new line with the\n\n<pre>prompt already displayed.  Code originally ...</pre>\n"],["rl_overwrite_mode","RbReadline","RbReadline.html#method-i-rl_overwrite_mode","(count, key)","<p>Toggle overwrite mode.  A positive explicit argument selects overwrite\n\n<pre>mode.  A negative or zero explicit ...</pre>\n"],["rl_parse_and_bind","RbReadline","RbReadline.html#method-i-rl_parse_and_bind","(string)","<p>Read the binding command from STRING and perform it.\n\n<pre>A key binding command looks like: Keyname: function-name\\0, ...</pre>\n"],["rl_possible_completions","RbReadline","RbReadline.html#method-i-rl_possible_completions","(ignore, invoking_key)","<p>List the possible completions.  See description of rl_complete ().\n"],["rl_prep_terminal","RbReadline","RbReadline.html#method-i-rl_prep_terminal","(meta_flag)",""],["rl_quoted_insert","RbReadline","RbReadline.html#method-i-rl_quoted_insert","(count, key)",""],["rl_re_read_init_file","RbReadline","RbReadline.html#method-i-rl_re_read_init_file","(count, ignore)","<p>Re-read the current keybindings file.\n"],["rl_read_init_file","RbReadline","RbReadline.html#method-i-rl_read_init_file","(filename)","<p>Do key bindings from a file.  If FILENAME is NULL it defaults\n\n<pre>to the first non-null filename from this ...</pre>\n"],["rl_read_key","RbReadline","RbReadline.html#method-i-rl_read_key","()","<p>Read a key, including pending input.\n"],["rl_redisplay","RbReadline","RbReadline.html#method-i-rl_redisplay","()","<p>Basic redisplay algorithm.\n"],["rl_refresh_line","RbReadline","RbReadline.html#method-i-rl_refresh_line","(ignore1, ignore2)","<p>Clear the current line.  Numeric argument to C-l does this.\n"],["rl_replace_from_history","RbReadline","RbReadline.html#method-i-rl_replace_from_history","(entry, flags)",""],["rl_replace_line","RbReadline","RbReadline.html#method-i-rl_replace_line","(text, clear_undo)","<p>Replace the current line buffer contents with TEXT.  If CLEAR_UNDO is\n\n<pre>non-zero, we free the current undo ...</pre>\n"],["rl_reset_line_state","RbReadline","RbReadline.html#method-i-rl_reset_line_state","()",""],["rl_resize_terminal","RbReadline","RbReadline.html#method-i-rl_resize_terminal","()",""],["rl_restart_output","RbReadline","RbReadline.html#method-i-rl_restart_output","(count, key)",""],["rl_restore_prompt","RbReadline","RbReadline.html#method-i-rl_restore_prompt","()",""],["rl_reverse_search_history","RbReadline","RbReadline.html#method-i-rl_reverse_search_history","(sign, key)","<p>Search backwards through the history looking for a string which is typed\n\n<pre>interactively.  Start with the ...</pre>\n"],["rl_revert_line","RbReadline","RbReadline.html#method-i-rl_revert_line","(count, key)","<p>Revert the current line to its previous state.\n"],["rl_rubout","RbReadline","RbReadline.html#method-i-rl_rubout","(count, key)","<p>Rubout the character behind point.\n"],["rl_rubout_or_delete","RbReadline","RbReadline.html#method-i-rl_rubout_or_delete","(count, key)","<p>Delete the character under the cursor, unless the insertion\n\n<pre>point is at the end of the line, in which ...</pre>\n"],["rl_save_prompt","RbReadline","RbReadline.html#method-i-rl_save_prompt","()",""],["rl_search_history","RbReadline","RbReadline.html#method-i-rl_search_history","(direction, invoking_key)","<p>Search through the history looking for an interactively typed string.\n\n<pre>This is analogous to i-search.  ...</pre>\n"],["rl_set_keymap_from_edit_mode","RbReadline","RbReadline.html#method-i-rl_set_keymap_from_edit_mode","()",""],["rl_set_mark","RbReadline","RbReadline.html#method-i-rl_set_mark","(count, key)","<p>A bindable command to set the mark.\n"],["rl_set_prompt","RbReadline","RbReadline.html#method-i-rl_set_prompt","(prompt)","<p>Set up the prompt and expand it.  Called from readline() and\n\n<pre>rl_callback_handler_install ().</pre>\n"],["rl_set_signals","RbReadline","RbReadline.html#method-i-rl_set_signals","()",""],["rl_setstate","RbReadline","RbReadline.html#method-i-rl_setstate","(x)",""],["rl_sigwinch_handler","RbReadline","RbReadline.html#method-i-rl_sigwinch_handler","(sig)",""],["rl_stuff_char","RbReadline","RbReadline.html#method-i-rl_stuff_char","(key)","<p>Add KEY to the buffer of characters to be read.  Returns 1 if the\n\n<pre>character was stuffed correctly; 0 otherwise.</pre>\n"],["rl_tab_insert","RbReadline","RbReadline.html#method-i-rl_tab_insert","(count, key)","<p>Insert a tab character.\n"],["rl_tilde_expand","RbReadline","RbReadline.html#method-i-rl_tilde_expand","(ignore, key)","<p>A function for simple tilde expansion.\n"],["rl_transpose_chars","RbReadline","RbReadline.html#method-i-rl_transpose_chars","(count, key)","<p>Transpose the characters at point.  If point is at the end of the line,\n\n<pre>then transpose the characters ...</pre>\n"],["rl_transpose_words","RbReadline","RbReadline.html#method-i-rl_transpose_words","(count, key)","<p>Transpose the words at point.  If point is at the end of the line,\n\n<pre>transpose the two words before point.</pre>\n"],["rl_tty_set_default_bindings","RbReadline","RbReadline.html#method-i-rl_tty_set_default_bindings","(kmap)","<p>New public way to set the system default editing chars to their readline\n\n<pre>equivalents.</pre>\n"],["rl_tty_unset_default_bindings","RbReadline","RbReadline.html#method-i-rl_tty_unset_default_bindings","(kmap)","<p>Rebind all of the tty special chars that readline worries about back\n\n<pre>to self-insert.  Call this before ...</pre>\n"],["rl_undo_command","RbReadline","RbReadline.html#method-i-rl_undo_command","(count, key)","<p>Do some undoing of things that were done.\n"],["rl_unix_filename_rubout","RbReadline","RbReadline.html#method-i-rl_unix_filename_rubout","(count, key)","<p>This deletes one filename component in a Unix pathname.  That is, it\n\n<pre>deletes backward to directory separator ...</pre>\n"],["rl_unix_line_discard","RbReadline","RbReadline.html#method-i-rl_unix_line_discard","(count, key)","<p>Here is C-u doing what Unix does.  You don&#39;t <strong>have</strong> to\nuse these key-bindings.  We have a choice of …\n"],["rl_unix_word_rubout","RbReadline","RbReadline.html#method-i-rl_unix_word_rubout","(count, key)","<p>This does what C-w does in Unix.  We can&#39;t prevent people from\n\n<pre>using behaviour that they expect.</pre>\n"],["rl_unsetstate","RbReadline","RbReadline.html#method-i-rl_unsetstate","(x)",""],["rl_upcase_word","RbReadline","RbReadline.html#method-i-rl_upcase_word","(count, key)","<p>Uppercase the word at point.\n"],["rl_username_completion_function","RbReadline","RbReadline.html#method-i-rl_username_completion_function","(text, state)","<p>A completion function for usernames.\n\n<pre>TEXT contains a partial username preceded by a random\ncharacter (usually ...</pre>\n"],["rl_variable_bind","RbReadline","RbReadline.html#method-i-rl_variable_bind","(name,value)",""],["rl_vi_check","RbReadline","RbReadline.html#method-i-rl_vi_check","()",""],["rl_vi_editing_mode","RbReadline","RbReadline.html#method-i-rl_vi_editing_mode","(count, key)","<p>This is a NOOP until the rest of Vi-mode is working.\n"],["rl_vi_insertion_mode","RbReadline","RbReadline.html#method-i-rl_vi_insertion_mode","(count, key)","<p>Switching from one mode to the other really just involves\n\n<pre>switching keymaps.</pre>\n"],["rl_yank","RbReadline","RbReadline.html#method-i-rl_yank","(count, ignore)","<p>Yank back the last killed text.  This ignores arguments.\n"],["rl_yank_last_arg","RbReadline","RbReadline.html#method-i-rl_yank_last_arg","(count, key)",""],["rl_yank_nth_arg","RbReadline","RbReadline.html#method-i-rl_yank_nth_arg","(count, ignore)","<p>Yank the COUNTth argument from the previous history line.\n"],["rl_yank_nth_arg_internal","RbReadline","RbReadline.html#method-i-rl_yank_nth_arg_internal","(count, ignore, history_skip)","<p>Yank the COUNTh argument from the previous history line, skipping\n\n<pre>HISTORY_SKIP lines before looking for ...</pre>\n"],["rl_yank_pop","RbReadline","RbReadline.html#method-i-rl_yank_pop","(count, key)","<p>If the last command was yank, or yank_pop, and the text just\n\n<pre>before point is identical to the current ...</pre>\n"],["save_tty_chars","RbReadline","RbReadline.html#method-i-save_tty_chars","()",""],["set_completion_defaults","RbReadline","RbReadline.html#method-i-set_completion_defaults","(what_to_do)","<p>Set default values for readline word completion.  These are the variables\n\n<pre>that application completion ...</pre>\n"],["sh_set_lines_and_columns","RbReadline","RbReadline.html#method-i-sh_set_lines_and_columns","(lines, cols)","<p>Set the environment variables LINES and COLUMNS to lines and cols,\n\n<pre>respectively.</pre>\n"],["shift","Readline::History","Readline/History.html#method-c-shift","()","<p>Removes and returns the first element from the history buffer.\n"],["shift","Readline::History","Readline/History.html#method-c-shift","()","<p>Removes and returns the first element from the history buffer.\n"],["size","Readline::History","Readline/History.html#method-c-size","()","<p>Synonym for Readline.length.\n"],["size","Readline::History","Readline/History.html#method-c-size","()","<p>Synonym for Readline.length.\n"],["space_to_eol","RbReadline","RbReadline.html#method-i-space_to_eol","(count)","<p>Clear to the end of the line using spaces.  COUNT is the minimum\n\n<pre>number of character spaces to clear,</pre>\n"],["stat_char","RbReadline","RbReadline.html#method-i-stat_char","(filename)","<p>Return the character which best describes FILENAME.\n\n<pre>`@&#39; for symbolic links\n`/&#39; for directories\n`*&#39; for ...</pre>\n"],["stifle_history","RbReadline","RbReadline.html#method-i-stifle_history","(max)","<p>Stifle the history list, remembering only MAX number of lines.\n"],["tgetflag","RbReadline","RbReadline.html#method-i-tgetflag","(name)",""],["to_s","Readline::History","Readline/History.html#method-c-to_s","()","<p>The History class, stringified in all caps.\n"],["to_s","Readline::History","Readline/History.html#method-c-to_s","()","<p>The History class, stringified in all caps.\n"],["trans","RbReadline","RbReadline.html#method-i-trans","(i)","<p>Undo the next thing in the list.  Return 0 if there\n\n<pre>is nothing to undo, or non-zero if there was.</pre>\n"],["unstifle_history","RbReadline","RbReadline.html#method-i-unstifle_history","()","<p>Stop stifling the history.  This returns the previous maximum\n\n<pre>number of history entries.  The value is ...</pre>\n"],["update_line","RbReadline","RbReadline.html#method-i-update_line","(old, ostart, new, current_line, omax, nmax, inv_botlin)","<p>PWP: update_line() is based on finding the middle difference of each\n\n<pre> line on the screen; vis:\n\n      ...</pre>\n"],["using_history","RbReadline","RbReadline.html#method-i-using_history","()",""],["vi_editing_mode","Readline","Readline.html#method-c-vi_editing_mode","()","<p>Sets vi editing mode.\n"],["vis_chars","RbReadline","RbReadline.html#method-i-vis_chars","(line)",""],["vis_line","RbReadline","RbReadline.html#method-i-vis_line","(line)",""],["vis_llen","RbReadline","RbReadline.html#method-i-vis_llen","(l)",""],["vis_pos","RbReadline","RbReadline.html#method-i-vis_pos","(line)",""],["w_offset","RbReadline","RbReadline.html#method-i-w_offset","(line, offset)",""],["where_history","RbReadline","RbReadline.html#method-i-where_history","()","<p>Returns the magic number which says what history element we are\n\n<pre>looking at now.  In this implementation, ...</pre>\n"],["whitespace","RbReadline","RbReadline.html#method-i-whitespace","(c)",""],["CHANGES","","CHANGES.html","","<p>0.5.1 / 2014-01-08\n<p>Bugfixes:\n<p>Fix double require issues. Fixes #93, #95 [yui-knk]\n"],["LICENSE","","LICENSE.html","","<p>Copyright © 2009, Park Heesob All rights reserved.\n<p>Redistribution and use in source and binary forms, …\n"],["README","","README_rdoc.html","","<p>Description\n<p>The readline library provides a pure Ruby implementation of the GNU\nreadline C library, as …\n"]]}}